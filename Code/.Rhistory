mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
#Apply centered log ratio transfo
transformed_data[,2:ncol(transformed_data)] <- as.data.frame(compositions::clr(transformed_data[, 2:ncol(transformed_data)]))
return(transformed_data)
}
}
load_classification_objects()
load_classification_objects()
load_classification_objects()
load_classification_objects()
load_classification_objects()
load_classification_objects()
data <- Trial_summary
# Convert data to sf format
data_sf <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)
data_sf <- st_transform(data_sf, st_crs(lakes_buffer))
data_sf$longitude <- data$longitude
data_sf$latitude <- data$latitude
# Predict event type for inland locations using LDA
data_sf <- as.data.frame(data_sf)
inland_data <- data_sf %>% filter(location_type == "Inland")
LDA_dataset <- inland_data %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
# Assign event type based on location type
data_sf$location_type <- "Inland"
inland_data <- data_sf %>% filter(location_type == "Inland")
LDA_dataset <- inland_data %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
logratio_transfo <<- function(data, id_col_name){
data <- data %>% relocate(id_col_name, everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
#Apply centered log ratio transfo
transformed_data[,2:ncol(transformed_data)] <- as.data.frame(compositions::clr(transformed_data[, 2:ncol(transformed_data)]))
return(transformed_data)
}
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
logratio_transfo <<- function(data, id_col_name){
data <- data %>% relocate(all_of(id_col_name), everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
#Apply centered log ratio transfo
transformed_data[,2:ncol(transformed_data)] <- as.data.frame(compositions::clr(transformed_data[, 2:ncol(transformed_data)]))
return(transformed_data)
}
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
LDA_dataset <- inland_data %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
LDA_dataset <- LDA_dataset %>% dplyr::select(-event_id)
inland_class <- predict(LDA_model, LDA_dataset)$class
View(LDA_dataset)
load_classification_objects <- function(){ #Load required datasets, model and function
# Set the GitHub repository and folder path
folder_path = "Models"
repo_url <- "https://github.com/EManzo13/Caspian-gull-NL"
# Clone the GitHub repository to a temporary directory
temp_import_dir <- tempfile("githubRepo")
clone(url = repo_url, local_path = temp_import_dir)
# Construct the path and get the list of files in the folder
data_dir <- file.path(temp_import_dir, folder_path)
files_list <- dir_ls(path = data_dir)
# Import and check validity
LDA_model <<- readRDS(files_list[1])
lakes_buffer <<- readRDS(files_list[6])
lakes_buffer <<- st_make_valid(lakes_buffer)
ijsselmeer_coast <<- readRDS(files_list[4])
st_crs(ijsselmeer_coast) <- st_crs(lakes_buffer)
ijsselmeer_coast <<- st_make_valid(ijsselmeer_coast)
ijsselmeer <<- readRDS(files_list[5])
st_crs(ijsselmeer) <- st_crs(lakes_buffer)
ijsselmeer <<- st_make_valid(ijsselmeer)
# Define areas that need different buffer size (Agri close to water)
coastal_agri_areas <<- st_sfc(
st_polygon(list(rbind(c(5.09133928, 52.77384980), c(5.11180990, 52.77457775), c(5.12191121, 52.84782449), c(5.06827085, 52.90514619), c(5.05781206, 52.90153375), c(5.09787862, 52.84613331), c(5.09133928, 52.77384980)))),
st_polygon(list(rbind(c(5.17694879, 52.74266369), c(5.18896509, 52.75768205), c(5.22312570, 52.75669917), c(5.23209434, 52.75632622), c(5.22883277, 52.74832997), c(5.19748697, 52.74971954), c(5.18452654, 52.74015506), c(5.17694879, 52.74266369)))),
st_polygon(list(rbind(c(5.23825157, 52.68349655), c(5.25244771, 52.68324193), c(5.24249135, 52.65369382), c(5.16201076, 52.61870670), c(5.12767849, 52.61497096), c(5.10192928, 52.62664286), c(5.10776577, 52.63916130), c(5.14862117, 52.63438551), c(5.22552547, 52.66023106), c(5.23825157, 52.68349655)))),
st_polygon(list(rbind(c(5.01369242, 52.61160676), c(5.02605204, 52.61171914), c(5.02944771, 52.59240372), c(5.07545296, 52.52186933), c(5.05931679, 52.51812533), c(5.01475888, 52.59257740), c(5.01369242, 52.61160676)))),
st_polygon(list(rbind(c(5.49891787, 52.55687130), c(5.50591307, 52.55402928), c(5.56485286, 52.58746116), c(5.66128225, 52.61240403), c(5.63449307, 52.64914882), c(5.60977383, 52.64741085), c(5.62899991, 52.61573776), c(5.55691642, 52.59457487), c(5.49891787, 52.55687130)))),
st_polygon(list(rbind(c(5.59022867, 52.67668654), c(5.59812509, 52.67700284), c(5.60567040, 52.76554717), c(5.66764015, 52.82837470), c(5.69836754, 52.83120742), c(5.69685685, 52.83611943), c(5.66235291, 52.83166010), c(5.58786474, 52.76480491), c(5.59022867, 52.67668654)))),
st_polygon(list(rbind(c(5.65385167, 52.85397276), c(5.65771808, 52.85563124), c(5.64355199, 52.86257547), c(5.61608617, 52.85304793), c(5.58064410, 52.84939558), c(5.56558242, 52.83579410), c(5.54017654, 52.83652810), c(5.45551341, 52.85615149), c(5.41551182, 52.85117771), c(5.37036488, 52.87398593), c(5.36624500, 52.87254346), c(5.41534016, 52.84869780), c(5.45534175, 52.85242794), c(5.54154983, 52.82855064), c(5.56850067, 52.83331331), c(5.58545062, 52.84764128), c(5.61763112, 52.84879767), c(5.64320867, 52.85905977), c(5.65385167, 52.85397276))))
)
st_crs(coastal_agri_areas) <- st_crs(lakes_buffer)
coastal_agri_areas <<- st_make_valid(coastal_agri_areas)
# Define garbage places
garbage <<- st_sfc(
st_polygon(list(rbind(c(5.06082061, 52.77239580), c(5.07343773, 52.77252764), c(5.07210735, 52.76863505), c(5.06760124, 52.76692131), c(5.06060604, 52.76850523), c(5.06082061, 52.77239580)))),
st_polygon(list(rbind(c(5.24583702, 52.41666079), c(5.25343304, 52.41975134), c(5.25660877, 52.41776421), c(5.24832611, 52.41443998), c(5.24583702, 52.41666079)))),
st_polygon(list(rbind(c(4.75742737, 52.60589692), c(4.76298490, 52.60467299), c(4.75856069, 52.59685102), c(4.75323919, 52.60099557), c(4.75742737, 52.60589692)))),
st_polygon(list(rbind(c(5.06312263, 52.67185655), c(5.06726396, 52.67235800), c(5.06852997, 52.67002941), c(5.06444228, 52.66960703), c(5.06312263, 52.67185655)))),
st_polygon(list(rbind(c(5.26978458, 52.69643292), c(5.27315343, 52.69604279), c(5.27313189, 52.69441723), c(5.26977377, 52.69448926), c(5.26978458, 52.69643292)))),
st_polygon(list(rbind(c(4.78194988, 52.79300250), c(4.78574789, 52.79301573), c(4.78569956, 52.79134451), c(4.78185328, 52.79137046), c(4.78194988, 52.79300250)))),
st_polygon(list(rbind(c(4.77784276, 52.70404775), c(4.78102923, 52.70476335), c(4.78274778, 52.70236381), c(4.77946475, 52.70149914), c(4.77784276, 52.70404775))))
)
st_crs(garbage) <<- st_crs(lakes_buffer)
garbage <<- st_make_valid(garbage)
logratio_transfo <<- function(data, id_col_name){
data <- data %>% relocate(all_of(id_col_name), everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
#Apply centered log ratio transfo
transformed_data[,2:ncol(transformed_data)] <- as.data.frame(compositions::clr(transformed_data[, 2:ncol(transformed_data)]))
return(transformed_data)
}
}
load_classification_objects()
# Convert data to sf format
data_sf <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)
data_sf <- st_transform(data_sf, st_crs(lakes_buffer))
data_sf$longitude <- data$longitude
data_sf$latitude <- data$latitude
# Calculate distance to IJsselmeer coast
distance_matrix <- st_distance(data_sf, ijsselmeer_coast)
data_sf$distance_to_coastline <- apply(distance_matrix, 1, min)
# Define location types with distance to coast according to agri areas
data_sf$ijsselmeer <- lengths(st_within(data_sf, ijsselmeer)) > 0
data_sf$other_lakes <- lengths(st_within(data_sf, lakes_buffer)) > 0
data_sf$other_lakes <- lengths(st_within(data_sf, lakes_buffer)) > 0
data_sf$coastal_agri <- lengths(st_within(data_sf, coastal_agri_areas)) > 0
data_sf$garbage <- lengths(st_within(data_sf, garbage)) > 0
# Assign event type based on location type
data_sf$location_type <- "Inland"
data_sf$location_type[data_sf$ijsselmeer & data_sf$distance_to_coastline > 1000] <- "IJsselmeer"
data_sf$location_type[data_sf$other_lakes] <- "Other Lake"
data_sf$location_type[data_sf$distance_to_coastline <= 1000 & !data_sf$coastal_agri] <- "Coast"
data_sf$location_type[data_sf$distance_to_coastline <= 400 & data_sf$coastal_agri] <- "Coast"
data_sf$location_type[data_sf$garbage] <- "Garbage"
# Predict event type for inland locations using LDA
data_sf <- as.data.frame(data_sf)
inland_data <- data_sf %>% filter(location_type == "Inland")
LDA_dataset <- inland_data %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
# Predict event type for inland locations using LDA
data_sf <- as.data.frame(data_sf)
inland_data <- data_sf %>% filter(location_type == "Inland")
View(data_sf)
View(events_seq_trial)
View(Trial_summary)
LDA_dataset <- inland_data %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
data <- LDA_dataset
data <- data %>% relocate(all_of(id_col_name), everything())
id_col_name="event_id"
data <- data %>% relocate(all_of(id_col_name), everything())
View(data)
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
View(data)
View(transformed_data)
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
transformed_data <- transformed_data[,2:9]
transformed_data <- as.data.frame(compositions::clr(transformed_data))
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
transformed_data <- transformed_data[,2:9]
View(transformed_data)
transformed_data <- zCompositions::multLN(as.matrix(transformed_data), label = 0.001, dl = dl, z.warning = 1)
# Convert data to sf format
data_sf <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)
data_sf <- st_transform(data_sf, st_crs(lakes_buffer))
# Convert data to sf format
data_sf <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)
data_sf <- st_transform(data_sf, st_crs(lakes_buffer))
data <- Trial_summary
# Convert data to sf format
data_sf <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)
data_sf <- st_transform(data_sf, st_crs(lakes_buffer))
data_sf$longitude <- data$longitude
data_sf$latitude <- data$latitude
# Calculate distance to IJsselmeer coast
distance_matrix <- st_distance(data_sf, ijsselmeer_coast)
data_sf$distance_to_coastline <- apply(distance_matrix, 1, min)
# Define location types with distance to coast according to agri areas
data_sf$ijsselmeer <- lengths(st_within(data_sf, ijsselmeer)) > 0
data_sf$other_lakes <- lengths(st_within(data_sf, lakes_buffer)) > 0
data_sf$other_lakes <- lengths(st_within(data_sf, lakes_buffer)) > 0
data_sf$coastal_agri <- lengths(st_within(data_sf, coastal_agri_areas)) > 0
data_sf$garbage <- lengths(st_within(data_sf, garbage)) > 0
data_sf$garbage <- lengths(st_within(data_sf, garbage)) > 0
# Assign event type based on location type
data_sf$location_type <- "Inland"
# Predict event type for inland locations using LDA
data_sf <- as.data.frame(data_sf)
inland_data <- data_sf %>% filter(location_type == "Inland")
LDA_dataset <- inland_data %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
data <- LDA_dataset
data <- data %>% relocate(all_of(id_col_name), everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
#Apply centered log ratio transfo
transformed_data[,2:ncol(transformed_data)] <- as.data.frame(compositions::clr(transformed_data[, 2:ncol(transformed_data)]))
LDA_dataset <- LDA_dataset[1:13,]
data <- LDA_dataset
data <- data %>% relocate(all_of(id_col_name), everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
LDA_dataset <- LDA_dataset[1:11,]
data <- LDA_dataset
data <- data %>% relocate(all_of(id_col_name), everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
LDA_dataset <- LDA_dataset[1:10,]
data <- LDA_dataset
data <- data %>% relocate(all_of(id_col_name), everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
logratio_transfo <<- function(data, id_col_name){
data <- data %>% relocate(all_of(id_col_name), everything())
# Replace the zeros
transformed_data <- data %>%
mutate(across(-id_col_name, ~ ifelse(. == 0, 0.001, .))) # Replace zeros with 0.001
dl <- rep(0.001, ncol(transformed_data) - 1)
# Apply multiplicative lognormal replacement for zeros
transformed_data[,2:ncol(transformed_data)] <- zCompositions::multLN(as.matrix(transformed_data[, 2:ncol(transformed_data)]), label = 0.001, dl = dl, z.warning = 1)
#Apply centered log ratio transfo
transformed_data[,2:ncol(transformed_data)] <- as.data.frame(compositions::clr(transformed_data[, 2:ncol(transformed_data)]))
return(transformed_data)
}
data <- Trial_summary
# Convert data to sf format
data_sf <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)
data_sf <- st_transform(data_sf, st_crs(lakes_buffer))
data_sf$longitude <- data$longitude
data_sf$latitude <- data$latitude
# Calculate distance to IJsselmeer coast
distance_matrix <- st_distance(data_sf, ijsselmeer_coast)
data_sf$distance_to_coastline <- apply(distance_matrix, 1, min)
# Define location types with distance to coast according to agri areas
data_sf$ijsselmeer <- lengths(st_within(data_sf, ijsselmeer)) > 0
data_sf$other_lakes <- lengths(st_within(data_sf, lakes_buffer)) > 0
data_sf$other_lakes <- lengths(st_within(data_sf, lakes_buffer)) > 0
data_sf$coastal_agri <- lengths(st_within(data_sf, coastal_agri_areas)) > 0
data_sf$garbage <- lengths(st_within(data_sf, garbage)) > 0
data_sf$garbage <- lengths(st_within(data_sf, garbage)) > 0
# Assign event type based on location type
data_sf$location_type <- "Inland"
data_sf$location_type[data_sf$ijsselmeer & data_sf$distance_to_coastline > 1000] <- "IJsselmeer"
data_sf$location_type[data_sf$other_lakes] <- "Other Lake"
data_sf$location_type[data_sf$distance_to_coastline <= 1000 & !data_sf$coastal_agri] <- "Coast"
data_sf$location_type[data_sf$distance_to_coastline <= 400 & data_sf$coastal_agri] <- "Coast"
data_sf$location_type[data_sf$garbage] <- "Garbage"
# Predict event type for inland locations using LDA
data_sf <- as.data.frame(data_sf)
LDA_dataset <- data_sf %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
#condition to sort out events NOT inland
LDA_dataset$location_type <- data_sf$location_type
View(LDA_dataset)
LDA_dataset <- LDA_dataset[which(LDA_dataset$location_type == "Inland"),]
View(LDA_dataset)
LDA_dataset <- LDA_dataset %>% dplyr::select(-event_id,-location_type)
View(LDA_dataset)
inland_data <- data_sf %>% filter(location_type == "Inland")
LDA_dataset <- data_sf %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
LDA_dataset$location_type <- data_sf$location_type
LDA_dataset <- LDA_dataset[which(LDA_dataset$location_type == "Inland"),] #sort out events NOT inland
LDA_dataset <- LDA_dataset %>% dplyr::select(-event_id,-location_type) #keep only behaviour proportions
inland_class <- predict(LDA_model, LDA_dataset)$class
inland_data$inland_class <- inland_class
inland_data <- inland_data %>% dplyr::select(event_id, inland_class)
inland_data$inland_class <- as.character(inland_data$inland_class)
data_sf <- left_join(data_sf, inland_data, by = "event_id")
data_sf <- data_sf %>% mutate(event_type = ifelse(location_type == "Inland",inland_class,location_type))
results_table <- data_sf %>% dplyr::select(event_id,event_type)
results_table
View(results_table)
classify_events <- function(data) {
# Convert data to sf format
data_sf <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = 4326)
data_sf <- st_transform(data_sf, st_crs(lakes_buffer))
data_sf$longitude <- data$longitude
data_sf$latitude <- data$latitude
# Calculate distance to IJsselmeer coast
distance_matrix <- st_distance(data_sf, ijsselmeer_coast)
data_sf$distance_to_coastline <- apply(distance_matrix, 1, min)
# Define location types with distance to coast according to agri areas
data_sf$ijsselmeer <- lengths(st_within(data_sf, ijsselmeer)) > 0
data_sf$other_lakes <- lengths(st_within(data_sf, lakes_buffer)) > 0
data_sf$coastal_agri <- lengths(st_within(data_sf, coastal_agri_areas)) > 0
data_sf$garbage <- lengths(st_within(data_sf, garbage)) > 0
# Assign event type based on location type
data_sf$location_type <- "Inland"
data_sf$location_type[data_sf$ijsselmeer & data_sf$distance_to_coastline > 1000] <- "IJsselmeer"
data_sf$location_type[data_sf$other_lakes] <- "Other Lake"
data_sf$location_type[data_sf$distance_to_coastline <= 1000 & !data_sf$coastal_agri] <- "Coast"
data_sf$location_type[data_sf$distance_to_coastline <= 400 & data_sf$coastal_agri] <- "Coast"
data_sf$location_type[data_sf$garbage] <- "Garbage"
# Predict event type for inland locations using LDA
data_sf <- as.data.frame(data_sf)
inland_data <- data_sf %>% filter(location_type == "Inland")
LDA_dataset <- data_sf %>% dplyr::select(event_id,SitStand,TerLoco,Float,Pecking,Flap,Soar,ExFlap,Manouvre)
LDA_dataset <- logratio_transfo(LDA_dataset, "event_id")
LDA_dataset$location_type <- data_sf$location_type
LDA_dataset <- LDA_dataset[which(LDA_dataset$location_type == "Inland"),] #sort out events NOT inland
LDA_dataset <- LDA_dataset %>% dplyr::select(-event_id,-location_type) #keep only behaviour proportions
inland_class <- predict(LDA_model, LDA_dataset)$class
inland_data$inland_class <- inland_class
inland_data <- inland_data %>% dplyr::select(event_id, inland_class)
inland_data$inland_class <- as.character(inland_data$inland_class)
data_sf <- left_join(data_sf, inland_data, by = "event_id")
data_sf <- data_sf %>% mutate(event_type = ifelse(location_type == "Inland",inland_class,location_type))
results_table <- data_sf %>% dplyr::select(event_id,event_type)
return(results_table)
}
Trial_summary <- left_join(Trial_summary, event_types, by = "event_id") # adds event_types column
event_types <- classify_events(Trial_summary)
Trial_summary <- left_join(Trial_summary, event_types, by = "event_id") # adds event_types column
# Final result table: event ID, individual, date, time, duration and event type
feeding_events <- All_events_summary %>% dplyr::select(event_id,device_info_serial,start_time,end_time,event_type)
# Final result table: event ID, individual, date, time, duration and event type
feeding_events <- Trial_summary %>% dplyr::select(event_id,device_info_serial,start_time,end_time,event_type)
View(feeding_events)
feeding_events$date <- as.Date(feeding_events$start_time, tz = "CET")
feeding_events$month <- month(feeding_events$date)
feeding_events$duration <- as.numeric(feeding_events$end_time - feeding_events$start_time, units="mins")
rm(data,data_sf,inland_data,LDA_dataset)
as.numeric(feeding_events$end_time)
as.Date(feeding_events$end_time, tz = "CET")
as.POSIXct(feeding_events$end_time, tz = "CET")
as.POSIXct(feeding_events$end_time, tz = "CET") - as.Date(feeding_events$start_time, tz = "CET")
as.character(as.POSIXct(feeding_events$end_time))
as.numeric(as.POSIXct(feeding_events$end_time))
as.numeric(as.POSIXct(feeding_events$start_time))
as.numeric(as.POSIXct(feeding_events$end_time, tz = "CET")) - as.numeric(as.Date(feeding_events$start_time, tz = "CET"))
as.numeric(as.POSIXct(feeding_events$end_time, tz = "CET")) - as.numeric(as.Date(feeding_events$start_time, tz = "CET"))
as.numeric(as.POSIXct(feeding_events$end_time, tz = "CET"))
as.numeric(as.Date(feeding_events$start_time, tz = "CET"))
as.numeric(as.POSIXct(feeding_events$end_time, tz = "CET")) - as.numeric(as.POSIXct(feeding_events$start_time, tz = "CET"))
(as.numeric(as.POSIXct(feeding_events$end_time, tz = "CET")) - as.numeric(as.POSIXct(feeding_events$start_time, tz = "CET")))/60
# Final result table: event ID, individual, date, time, duration and event type
feeding_events <- Trial_summary %>% dplyr::select(event_id,device_info_serial,start_time,end_time,event_type)
feeding_events$date <- as.Date(feeding_events$start_time, tz = "CET")
feeding_events$month <- month(feeding_events$date)
feeding_events$duration.in.min <- (as.numeric(as.POSIXct(feeding_events$end_time, tz = "CET")) - as.numeric(as.POSIXct(feeding_events$start_time, tz = "CET")))/60
# Final result table: event ID, individual, date, time, duration and event type
feeding_events <- Trial_summary %>% dplyr::select(event_id,device_info_serial,start_time,end_time,event_type)
feeding_events$duration.in.min <- (as.numeric(as.POSIXct(feeding_events$end_time, tz = "CET")) - as.numeric(as.POSIXct(feeding_events$start_time, tz = "CET")))/60
feeding_events$date <- as.Date(feeding_events$start_time, tz = "CET")
feeding_events$month <- month(feeding_events$date)
rm(transformed_data)
rm(distance_matrix,dl,id_col_name)
rm(inland_class)
View(HMM_states)
stateNames <- c("ARS", "Stationary", "Exploratory", "Transit")
myColors <- c("ARS" = "#FB8072","Stationary" = "#B3DE69", "Exploratory" = "#FDB462","Transit" = "#80B1D3")
track_plot <- function(data,track){
cur_set <- which(data$track == track)
subset <- data[cur_set,]
plot <- ggplot(subset, aes(x = longitude, y = latitude)) +
geom_segment(aes(xend = lead(longitude), yend = lead(latitude), col = HMM_state)) +
geom_point(aes(col = HMM_state), size = 1.5) +
scale_color_manual(name = "Activity", values = myColors) +
labs(
title = paste0("Route of track ", track),
x = "Longitude",
y = "Latitude",
subtitle = paste("Device ", unique(subset$device_info_serial), ", from ", min(subset$date_time), " until ", max(subset$date_time), sep = "")) +
theme_classic()
return(plot)
}
# All tracks
for(i in min(HMM_states$track):max(HMM_states$track)){
if(i <= max(HMM_states$track)){
plot <- track_plot(HMM_states,i)
print(plot)
readline(prompt = "Press [enter] to continue to the next track")
}
else {stop()}
}
# All tracks
for(i in min(HMM_states$track):max(HMM_states$track)){
if(i <= max(HMM_states$track)){
plot <- track_plot(HMM_states,i)
print(plot)
readline(prompt = "Press [enter] to continue to the next track")
}
else {stop()}
}
track_plot <- function(data,track){
cur_set <- which(data$track == track)
subset <- data[cur_set,]
plot <- ggplot(subset, aes(x = longitude, y = latitude)) +
geom_segment(aes(xend = lead(longitude), yend = lead(latitude), col = HMM_state)) +
geom_point(aes(col = HMM_state), size = 1.5) +
scale_color_manual(name = "Activity", values = myColors) +
labs(
title = paste0("Route of track ", track),
x = "Longitude",
y = "Latitude",
subtitle = paste("Device ", unique(subset$device_info_serial), ", from ", min(subset$date_time), " until ", max(subset$date_time), sep = "")) +
theme_classic()
return(plot)
}
# All tracks
for(i in min(HMM_states$track):max(HMM_states$track)){
if(i <= max(HMM_states$track)){
plot <- track_plot(HMM_states,i)
print(plot)
readline(prompt = "Press [enter] to continue to the next track")
}
else {stop()}
}
# All tracks
for(i in min(HMM_states$track):max(HMM_states$track)){
if(i <= max(HMM_states$track)){
plot <- track_plot(HMM_states,i)
print(plot)
}
else {stop()}
}
stateNames <- c("ARS", "Stationary", "Exploratory", "Transit")
myColors <- c("ARS" = "#FB8072","Stationary" = "#B3DE69", "Exploratory" = "#FDB462","Transit" = "#80B1D3")
track_plot <- function(data,track){
cur_set <- which(data$track == track)
subset <- data[cur_set,]
plot <- ggplot(subset, aes(x = longitude, y = latitude)) +
geom_segment(aes(xend = lead(longitude), yend = lead(latitude), col = HMM_state)) +
geom_point(aes(col = HMM_state), size = 1.5) +
scale_color_manual(name = "Activity", values = myColors) +
labs(
title = paste0("Route of track ", track),
x = "Longitude",
y = "Latitude",
subtitle = paste("Device ", unique(subset$device_info_serial), ", from ", min(subset$date_time), " until ", max(subset$date_time), sep = "")) +
theme_classic()
return(plot)
}
# All tracks
for(i in min(HMM_states$track):max(HMM_states$track)){
if(i <= max(HMM_states$track)){
plot <- track_plot(HMM_states,i)
print(plot)
}
else {stop()}
}
import_and_merge <- function(feeding_sequences_table){
# Set the GitHub repository and folder path
folder_path = "Trial_datasets/Behavioural_model_output"
repo_url <- "https://github.com/EManzo13/Caspian-gull-NL"
# Clone the GitHub repository to a temporary directory
temp_import_dir <- tempfile("githubRepo")
clone(url = repo_url, local_path = temp_import_dir)
# Construct the path and get the list of files in the folder
data_dir <- file.path(temp_import_dir, folder_path)
files_list <- dir_ls(path = data_dir, glob = "*.csv")
# Import and merge
all_behav_events <- data.frame()
imported_event_ids <- numeric()
for (file_path in files_list){
behav_event <- read.csv(file_path)
behav_event$date_time <- as.POSIXct(behav_event$date_time)
file_info <- strsplit(basename(file_path), "_\"|\"_\"|\".csv")[[1]]
device <- file_info[1]
start_time_file <- as.POSIXct(file_info[2], format = "%Y-%m-%d %H:%M:%OS")
end_time_file <- as.POSIXct(file_info[3], format = "%Y-%m-%d %H:%M:%OS")
matched_event <- feeding_sequences_table %>%
filter(device_info_serial == device,
start_time <= start_time_file,
end_time >= end_time_file)
if (nrow(matched_event) == 1) {
event_id <- matched_event$event_id
# Check if event_id already exists in all_behav_events
if (!(event_id %in% imported_event_ids)) {
behav_event$event_id <- event_id
behav_event <- behav_event %>% relocate(event_id, everything())
all_behav_events <- bind_rows(all_behav_events, behav_event)
imported_event_ids <- c(imported_event_ids, event_id)
} else {
message(paste("Event_id", event_id, "already imported. Skipping duplicate."))
}
} else if (nrow(matched_event) == 0) {
message(paste("Event_id", event_id, "filtered out. Skipping"))
} else {
cat(nrow(matched_event)," event(s) found,\nLast working track:", max(all_behav_events$event_id),"\nLast imported file:",i)
stop()}
}
return(all_behav_events)
}
Trial_behaviour_combined <- import_and_merge(events_seq_trial)
